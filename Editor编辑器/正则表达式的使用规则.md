# 正则表达式的使用规则
正则表达式（Regular Expression，简称 regex 或 regexp）是一种用于匹配字符串模式的工具，广泛应用于文本搜索、替换和验证等场景。
它由一系列字符和特殊符号组成，能够高效地处理复杂的字符串匹配任务。

主要用途
1. 文本搜索：快速查找符合特定模式的字符串。
2. 文本替换：将匹配的字符串替换为指定内容。
3. 数据验证：检查输入是否符合特定格式（如邮箱、电话号码等）。
4. 字符串分割：根据模式将字符串拆分为多个部分。

## 1. 使用规范表
| 元字符/序列 | 功能描述 | 示例 |
|-------------|----------|------|
| `.`         | 匹配任意单个字符（除换行符外） | `a.b` 匹配 `aXb`、`a1b`、`a b` 等 |
| `^`         | 匹配字符串的开始位置 | `^abc` 匹配以 `abc` 开头的字符串 |
| `$`         | 匹配字符串的结束位置 | `abc$` 匹配以 `abc` 结尾的字符串 |
| `*`         | 匹配前面的字符零次或多次 | `a*` 匹配 `a`、`aa`、`aaa`、空字符串等 |
| `+`         | 匹配前面的字符一次或多次 | `a+` 匹配 `a`、`aa`、`aaa` 等，不匹配空字符串 |
| `?`         | 匹配前面的字符零次或一次 | `a?` 匹配 `a` 和空字符串 |
| `{n}`       | 匹配前面的字符恰好 n 次 | `a{3}` 匹配 `aaa` |
| `{n,}`      | 匹配前面的字符至少 n 次 | `a{3,}` 匹配 `aaa`、`aaaa` 等 |
| `{n,m}`     | 匹配前面的字符至少 n 次，最多 m 次 | `a{2,4}` 匹配 `aa`、`aaa`、`aaaa` |
| `[]`        | 匹配方括号内的任意一个字符 | `[abc]` 匹配 `a`、`b`、`c` 中的任意一个 |
| `[^]`       | 匹配不在方括号内的任意一个字符 | `[^abc]` 匹配除 `a`、`b`、`c` 之外的任意一个字符 |
| `|`         | 匹配左边或右边的表达式 | `a|b` 匹配 `a` 或 `b` |
| `()`        | 分组，用于分组和捕获 | `(ab)+` 匹配 `ab`、`abab`、`ababab` 等 |
| `\`         | 转义特殊字符 | `\.` 匹配点号 `.`，而不是任意字符 |
| `\d`        | 匹配任意数字（0-9） | `\d{3}` 匹配 `123`、`456` 等 |
| `\D`        | 匹配任意非数字 | `\D{3}` 匹配 `abc`、`!@#` 等 |
| `\w`        | 匹配任意字母数字字符（包括下划线） | `\w{3}` 匹配 `abc`、`123`、`a1_` 等 |
| `\W`        | 匹配任意非字母数字字符 | `\W{3}` 匹配 `!@#`、`-+=` 等 |
| `\s`        | 匹配任意空白字符（空格、制表符、换行符等） | `\s{3}` 匹配 `   `、`	`（三个制表符）等 |
| `\S`        | 匹配任意非空白字符 | `\S{3}` 匹配 `abc`、`123` 等 |
| `(?=...)`   | 正向肯定预查，在任何匹配 `...` 的字符串开始处匹配 | `foo(?=bar)` 匹配 `foobar` 中的 `foo`，但不匹配 `foobaz` 中的 `foo` |
| `(?!...)`   | 正向否定预查，在任何不匹配 `...` 的字符串开始处匹配 | `foo(?!bar)` 匹配 `foobaz` 中的 `foo`，但不匹配 `foobar` 中的 `foo` |
| `(?<=...)`  | 反向肯定预查，在任何匹配 `...` 的字符串结束处匹配 | `(?<=foo)bar` 匹配 `foobar` 中的 `bar`，但不匹配 `bazbar` 中的 `bar` |
| `(?<!...)`  | 反向否定预查，在任何不匹配 `...` 的字符串结束处匹配 | `(?<!foo)bar` 匹配 `bazbar` 中的 `bar`，但不匹配 `foobar` 中的 `bar` |
| `\b`        | 匹配单词边界 | `\bword\b` 匹配 `word` 作为一个独立单词，不匹配 `sword` 或 `wording` |
| `\B`        | 匹配非单词边界 | `\Bword\B` 匹配 `swording` 中的 `word`，不匹配 `word` 作为一个独立单词 |
| `\A`        | 匹配字符串的开始位置，不受多行模式影响 | `\Aabc` 匹配以 `abc` 开头的整个字符串 |
| `\Z`        | 匹配字符串的结束位置，但在最后一个字符之后的换行符之前 | `abc\Z` 匹配以 `abc` 结尾的整个字符串，但在换行符之前 |
| `\z`        | 匹配字符串的结束位置，不受多行模式影响 | `abc\z` 匹配以 `abc` 结尾的整个字符串 |
| `\1`、`\2`、... | 匹配前面捕获的组 | `(\d{3})-(\d{2})-(\d{4})` 匹配 `123-45-6789`，`\1` 匹配 `123`，`\2` 匹配 `45`，`\3` 匹配 `6789` |
| `(?P<name>...)` | 命名捕获组 | `(?P<year>\d{4})-(?P<month>\d{2})-(?P<day>\d{2})` 匹配 `2023-10-01`，`(?P<year>\d{4})` 匹配 `2023`，`(?P<month>\d{2})` 匹配 `10`，`(?P<day>\d{2})` 匹配 `01` |
| `(?P=name)` | 匹配前面命名的捕获组 | `(?P<word>\w+)-(?P=word)` 匹配 `test-test`，但不匹配 `test-test1` |
| `(?i)`      | 忽略大小写匹配（在当前作用域内） | `(?i)hello` 匹配 `hello`、`HELLO`、`Hello` 等 |
| `(?m)`      | 多行模式，`^` 和 `$` 匹配每一行的开始和结束 | `(?m)^abc$` 匹配每一行以 `abc` 开头和结束 |
| `(?s)`      | 单行模式，`.` 匹配所有字符，包括换行符 | `(?s)a.*b` 匹配 `a\nb` |
| `(?x)`      | 忽略模式中的空白和注释 | `(?x) a \. b` 匹配 `a.b`，忽略空白和注释 |
| `(?#...)`   | 注释，注释内容不会影响匹配 | `a(?#这是注释)b` 匹配 `ab`，注释部分被忽略 |
### 示例
以下是一些示例，展示了如何使用这些正则表达式规则：
1. **匹配以 `http` 开头的 URL**：
   ```regex
   ^http://
   ```
2. **匹配以 `abc` 开头和以 `xyz` 结尾的字符串**：
   ```regex
   ^abc.*xyz$
   ```
3. **匹配包含 `123` 的字符串，但 `123` 不能出现在字符串的开头或结尾**：
   ```regex
   \B123\B
   ```
4. **匹配以 `foo` 开头，后面紧跟 `bar` 的字符串**：
   ```regex
   foo(?=bar)
   ```
5. **匹配以 `bar` 结尾，前面紧跟 `foo` 的字符串**：
   ```regex
   (?<=foo)bar
   ```
6. **匹配包含数字和字母的字符串**：
   ```regex
   \w+
   ```  