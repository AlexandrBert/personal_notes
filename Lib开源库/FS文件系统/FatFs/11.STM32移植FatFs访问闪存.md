# STM32 移植 FatFs 访问闪存

## 1. FatFs 开源库介绍
FatFs是一个通用的FAT/exFAT文件系统模块，用于小型嵌入式系统。

FatFs模块是按照ANSI C（C89）编写的，并且与磁盘控制层完全分离。因此，它独立于平台和存储设备。

它可以集成到资源有限的小型微控制器中，如8051，PIC，AVR，ARM，Z 80，RX等。

### 1.1. 下载地址
[http://elm-chan.org/fsw/ff/00index_e.html](http://elm-chan.org/fsw/ff/00index_e.html)

### 1.2. 文件介绍
下载源码，除了帮助接口文档外，只有几个源文件，需要移植时，将以下的 .c 和 .h 文件添加到工程目录即可。
- `00readme.txt`
- `00history.txt`：修订历史记录。
- `ff.c `：FatFs模块。
- `ffconf.h`：FatFs模块的配置文件。
- `ff.h `：FatF和应用程序模块的通用包含文件。
- `diskio.h `：FatF和磁盘I/O模块的通用包含文件。
- `diskio.c`：将现有磁盘I/O模块连接到FatF的粘合函数的示例。
- `ffunicode.c`：可选的Unicode实用程序函数。
- `ffsystem.c`：可选O/S相关函数的示例。

低级磁盘I/O模块不包括在此存档中，因为 FatF 模块只是一个通用文件系统层，它不依赖于任何特定的存储设备。

您需要提供写入的低级别磁盘I/O模块控制连接到目标系统的存储设备。

## 2. 源代码移植和修改
### 2.1. 修改 `ffconf.h` 配置文件
在 `ffconf.h` 文件中，根据实际需求进行配置。

以下配置是针对 STM32F103C8T6 的闪存进行配置的，仅展示部分配置。
```c
/*---------------------------------------------------------------------------/
/ Function Configurations
/---------------------------------------------------------------------------*/

#define FF_FS_READONLY	0   /* 非只读，可读可写的API设置为可用 */
#define FF_FS_MINIMIZE	0   /* 基本功能函数完全可用，包含stat文件信息等 */
#define FF_USE_FIND		0   /* 禁用过滤目录读取函数 f_findfirst() 和 f_findnext() */
#define FF_USE_MKFS		1   /* 启用 f_mkfs() 函数 */
#define FF_USE_FASTSEEK	0   /* 禁用快速查找功能 */
#define FF_USE_EXPAND	0   /* 禁用 f_expand() 函数 */
#define FF_USE_CHMOD	0   /* 禁用属性控制 API 函数 f_chmod() 和 f_utime()。 */
#define FF_USE_LABEL	0   /* 禁用卷标 API 函数 f_getlabel() 和 f_setlabel() */
#define FF_USE_FORWARD	0   /* 禁用 f_forward() 函数 */

#define FF_USE_STRFUNC	1   /* 启用 f_gets(), f_putc(), f_puts() and f_printf()，但不进行换行符（LF - CRLF）转换 */
#define FF_PRINT_LLI	0   /* 不支持 long long 类型 */
#define FF_PRINT_FLOAT	1   /* 支持浮点数类型，要求C99以上 */
#define FF_STRF_ENCODE	3   /* 使用 UTF-8 */

/*---------------------------------------------------------------------------/
/ Locale and Namespace Configurations
/---------------------------------------------------------------------------*/

#define FF_CODE_PAGE	437 /* 使用美国 OEM 字符集 */

#define FF_USE_LFN		0   /* 禁用长文件名支持，LEN 相关参数无效 */

#define FF_FS_RPATH		0   /* 禁用相对路径 */

/*---------------------------------------------------------------------------/
/ Drive/Volume Configurations
/---------------------------------------------------------------------------*/

#define FF_VOLUMES		1   /* 需要用到的卷（逻辑驱动器）数量，需要挂载多个逻辑驱动器时增加 */

#define FF_STR_VOLUME_ID	0   /* 禁用盘符字符串识别。启用时，可以通过下面的卷名，区分不同卷，可自行添加删除  */
#define FF_VOLUME_STRS		"RAM","NAND","CF","SD","SD2","USB","USB2","USB3"

#define FF_MULTI_PARTITION	0   /* 禁用物理驱动器上多个分区的支持，禁用 f_fdisk() 函数 */

#define FF_MIN_SS		1024    /* 最小扇区大小，stm32f103c8t6的flash单页大小为1024 */
#define FF_MAX_SS		4096    /* 最大扇区大小 */

#define FF_LBA64		0   /* 禁用 LBA 支持，启动时需要保证使用 exFAT(FF_FS_EXFAT == 1)，LBA64 相关参数无效 */

#define FF_USE_TRIM		0   /* 禁用 ATA-TRIM 功能，启动时，必须在 disk_ioctl() 中实现 CTRL_TRIM 命令 */

/*---------------------------------------------------------------------------/
/ System Configurations
/---------------------------------------------------------------------------*/

#define FF_FS_TINY		0   /* 文件对象的缓冲区配置模式使用普通模式，不使用微型缓存配置， */
#define FF_FS_EXFAT		0   /* 禁用对 exFAT 文件系统的支持 */

/* 禁用时间戳功能，所有文件对象的时间戳将固定为 FF_NORTC_MON、FF_NORTC_MDAY 和 FF_NORTC_YEAR 定义的值 */
#define FF_FS_NORTC		1
#define FF_NORTC_MON	11
#define FF_NORTC_MDAY	1
#define FF_NORTC_YEAR	2024

#define FF_FS_NOFSINFO	0   /* 信任 FSINFO 信息 */
#define FF_FS_LOCK		0   /* 禁用文件锁定功能，启用后需要自行避免非法操作 */
#define FF_FS_REENTRANT	0   /* 禁用重入性，FF_FS_TIMEOUT 无效，如果启用，需要完成互斥锁相关函数 */
#define FF_FS_TIMEOUT	1000
```

### 2.2. 添加底层接口函数
根据平台接口，需要完成以下函数接口：
- `diskio.c`
    - `disk_status()`：获取当前存储设备的状态；
    - `disk_initialize()`：初始化硬件；
    - `disk_read()`：读接口；
    - `disk_write()`：写接口；
    - `disk_ioctl()`：即调用 `disk_ioctl(pdrv, CTRL_TRIM, lba)` 时，指定的不同命令；
        - 需要实现包括 `CTRL_SYNC 、GET_SECTOR_COUNT、GET_BLOCK_SIZE、GET_SECTOR_SIZE` 命令。
- `ff.c`
    - `get_fattime()`：读 RTC 时钟，这里设置了 FF_FS_NORTC == 1 ，可以不实现该函数，固定使用相关宏定义时间。

`diskio.c` 文件的实现代码如下：
```c
#include "ff.h"			/* Obtains integer types */
#include "diskio.h"		/* Declarations of disk functions */
#include "flash.h"

/* Definitions of physical drive number for each drive */
#define DEV_FLSAH	0   /* 这里只有一种物理驱动，即内部 FLASH 驱动 */

/*-----------------------------------------------------------------------*/
/* Get Drive Status                                                      */
/*-----------------------------------------------------------------------*/

DSTATUS disk_status (
	BYTE pdrv		/* Physical drive nmuber to identify the drive */
)
{
	DSTATUS stat;
	// FLASH_Status state;

	switch (pdrv) {
	case DEV_FLSAH :
		state = flash_disk_status();
		if ((state == FLASH_BUSY) || (state == FLASH_ERROR_PG)) stat = STA_PROTECT;
		else if (state == FLASH_TIMEOUT) stat = STA_NODISK;
		else stat = 0;
		return stat;
	}
	return STA_NOINIT;
}



/*-----------------------------------------------------------------------*/
/* Inidialize a Drive                                                    */
/*-----------------------------------------------------------------------*/

DSTATUS disk_initialize (
	BYTE pdrv				/* Physical drive nmuber to identify the drive */
)
{
	DSTATUS stat;

	switch (pdrv) {
	case DEV_FLSAH :
		stat = 0;   /* 内部flash无需初始化驱动 */
		return stat;
	}
	return STA_NOINIT;
}



/*-----------------------------------------------------------------------*/
/* Read Sector(s)                                                        */
/*-----------------------------------------------------------------------*/

DRESULT disk_read (
	BYTE pdrv,		/* Physical drive nmuber to identify the drive */
	BYTE *buff,		/* Data buffer to store read data */
	LBA_t sector,	/* Start sector in LBA */
	UINT count		/* Number of sectors to read */
)
{
	DRESULT res;

	switch (pdrv) {
	case DEV_FLSAH :
		flash_disk_read(buff, sector, count);
		res = RES_OK;
	}

	return RES_PARERR;
}



/*-----------------------------------------------------------------------*/
/* Write Sector(s)                                                       */
/*-----------------------------------------------------------------------*/

#if FF_FS_READONLY == 0

DRESULT disk_write (
	BYTE pdrv,			/* Physical drive nmuber to identify the drive */
	const BYTE *buff,	/* Data to be written */
	LBA_t sector,		/* Start sector in LBA */
	UINT count			/* Number of sectors to write */
)
{
	DRESULT res;

	switch (pdrv) {
	case DEV_FLSAH :
		FLASH_Status ret = flash_disk_write(buff, sector, count);
		if(ret == FLASH_COMPLETE) return RES_OK;
		else if(ret == FLASH_ERROR_WRP) return RES_WRPRT;
		else if(ret == FLASH_TIMEOUT ) return RES_NOTRDY;
		else  return RES_ERROR;
		return res;
	}

	return RES_PARERR;
}

#endif


/*-----------------------------------------------------------------------*/
/* Miscellaneous Functions                                               */
/*-----------------------------------------------------------------------*/

DRESULT disk_ioctl (
	BYTE pdrv,		/* Physical drive nmuber (0..) */
	BYTE cmd,		/* Control code */
	void *buff		/* Buffer to send/receive control data */
)
{
	DRESULT res;

	switch (pdrv) {
	case DEV_RAM :

		// Process of the command for the RAM drive

		return res;
	}

	return RES_PARERR;
}


```