# 3.linux 下 PahoMqttC 库的应用 demo

## 1. Paho.Mqtt.C 库中的示例介绍
以下 demo 都是基于已有的 Paho.Mqtt.C 库中的示例更改而来，库中位于 `paho.mqtt.c/src/samples` 文件夹，共提供了以下几个示例：
```bash
.
├── MQTTAsync_publish.c     # 异步消息发布：使用 MQTTAsync 接口发送单条MQTT消息，不阻塞主线程
├── MQTTAsync_publish_time.c    # 带过期时间的异步消息发布：周期性发布消息（如每秒1条），展示异步定时任务实现。
├── MQTTAsync_subscribe.c       # 异步消息订阅：订阅主题并异步接收消息（通过回调函数处理到达的消息）
├── MQTTClient_publish_async.c  # 伪异步发布：使用同步API但通过线程模拟异步行为（非官方推荐方式）
├── MQTTClient_publish.c        # 基础同步发布：阻塞式发送消息，等待服务器确认后继续执行。
├── MQTTClient_subscribe.c      # 同步订阅：阻塞线程等待消息到达（通常配合循环使用）。
├── paho_c_pub.c                # 命令行发布工具：类似 mosquitto_pub，支持参数化主题/消息/QoS发布。
├── paho_cs_pub.c               # 加密发布示例：通过SSL/TLS加密通道发布消息（需配置证书）。
├── paho_cs_sub.c               # 加密订阅示例：通过SSL/TLS加密通道订阅消息。
├── paho_c_sub.c                # 命令行订阅工具：类似 mosquitto_sub，持续打印接收到的消息。
└── pubsub_opts.c               # 参数解析模块：统一处理命令行参数（如Broker地址、主题、QoS等）。
```

## 2. MQTTClient（依赖libpaho-mqtt3c） demo 的编译和运行
**代码功能说明**
- 包含一个订阅者线程，基于示例 `MQTTClient_subscribe.c` 更改：
    1. 连接服务器
    2. 订阅主题
    3. 接收消息
    4. 打印消息
    5. 接收到 SIGINT 信号后断开连接
- 包含一个发布者线程，基于示例 `MQTTClient_publish_async.c` 更改：
    1. 连接服务器
    2. 发布消息
    3. 打印消息
    4. 接收到 SIGINT 信号后断开连接

### 2.1. 编译操作
- 编译需要依赖线程库（指定 -pthread ）以及编译好的 MQTT 库（指定 -lpaho-mqtt3c）；
- 编译需要指定头文件路径；
编译命令如下，也可使用 Makefile 编译：
```bash
gcc -o test test.c  paho.mqtt.c/src/MQTTClient.h -pthread -lpaho-mqtt3c
```

### 2.2. 运行结果
运行结果如下：
```bash
root@light-14-prd1:~/github/paho_mqtt_c# ./test 
Hello World! It's me, thread #0!---------------------------------------->
Hello World! It's me, thread #1!---------------------------------------->
Subscribing to topic sub01
for client aaabbbccc_sub using QoS1

Press Q<Enter> to quit

Waiting for up to 10 seconds for publication of Hello Man, Can you see me ?!
on topic pub01 for s_pub_client.handle with ClientID: aaabbbccc_pub
Message with delivery token 1 delivered_callback
Waiting for up to 10 seconds for publication of Hello Man, Can you see me ?!
on topic pub01 for s_pub_client.handle with ClientID: aaabbbccc_pub
Message with delivery token 2 delivered_callback
^C
SIGINT signal capture...
Start to kill connection... 
Unsubscribe topic : sub01 success
Sub Client handle pointer = 0x7f2b4c020328
Pub Client handle pointer = 0x7f2b44000b78
OK
```

### 2.2. demo 源码
```c
/* test.c */
#include <pthread.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <signal.h>
#include "MQTTClient.h"

#if !defined(WIN32)
#include <unistd.h>
#else
#include <windows.h>
#endif

#define NUM_THREADS 2

typedef struct {
    MQTTClient handle;
    MQTTClient_connectOptions conn_opts ;
    char server_addr[128];    /* 服务器地址 */
    char client_id[64];
    char topic[64];
    char username[64];
    char password[64];
    int qos;
    int timeout;

    MQTTClient_message pub_msg;
    /* data */
}MQTT_client;

MQTT_client s_sub_client = {
    NULL,
    MQTTClient_connectOptions_initializer,   //连接初始化
    "mqtt://10.49.1.233:1883",  //更改此处地址
    "aaabbbccc_sub",            //更改此处客户端ID
    "sub01",                  //更改发送的话题
    "sub_user", //用户名
    "jim777",   //密码
    .qos = 1,   //QOS
    .timeout = 10000L
};

MQTT_client s_pub_client = {
    NULL,
    MQTTClient_connectOptions_initializer,   //连接初始化
    "mqtt://10.49.1.233:1883",  //更改此处地址
    "aaabbbccc_pub",            //更改此处客户端ID
    "pub01",                  //更改发送的话题
    "pub_user", //用户名
    "jim777",   //密码
    .qos = 1,   //QOS
    .timeout = 10000L,
    .pub_msg = MQTTClient_message_initializer
};

#define PAYLOAD "Hello Man, Can you see me ?!" //默认发送字符串

int CONNECT = 1;
volatile MQTTClient_deliveryToken deliveredtoken;

/* 定义传输成功回调函数 */
void delivered_callback(void *context, MQTTClient_deliveryToken dt)
{
    printf("Message with token value %d delivery confirmed\n", dt);
    deliveredtoken = dt;
}

/* 定义接收消息到达回调函数 */
int  msgarrvd_callback(void *context, char *topicName, int topicLen, MQTTClient_message *message)
{
    int i;
    char* payloadptr;

    printf("Message arrived\n");
    printf(" topic: %s\n", topicName);
    printf(" message: ");

    payloadptr = message->payload;
    if(strcmp(payloadptr, "out") == 0){
        printf(" \n out!!");
        CONNECT = 0;
    }

    for(i=0; i<message->payloadlen; i++)
    {
        putchar(*payloadptr++);
    }
    printf("\n");

    MQTTClient_freeMessage(&message);
    MQTTClient_free(topicName);
    return 1;
}

/* 连接失败回调函数 */
void connlost_callback(void *context, char *cause)
{
    printf("\nConnection lost\n");
    printf(" cause: %s\n", cause);
}

/* 订阅测试程序 */
void *subClient(void *threadid)
{
    long tid;
    tid = (long)threadid;
    printf("Hello World! It's me, thread #%ld!---------------------------------------->\n", tid);

    int rc;
    int ch;

    if ((rc = MQTTClient_create(&s_sub_client.handle, s_sub_client.server_addr, s_sub_client.client_id,
        MQTTCLIENT_PERSISTENCE_NONE, NULL)) != MQTTCLIENT_SUCCESS)
    {
        printf("Failed to create client, return code %d\n", rc);
        pthread_exit(NULL) ;
    }

    
    if ((rc = MQTTClient_setCallbacks(s_sub_client.handle, NULL, connlost_callback, msgarrvd_callback, delivered_callback)) != MQTTCLIENT_SUCCESS)
    {
        printf("Failed to set callbacks, return code %d\n", rc);
        goto destroy_exit;
    }

    s_sub_client.conn_opts.keepAliveInterval = 20;
    s_sub_client.conn_opts.cleansession = 1;
    if ((rc = MQTTClient_connect(s_sub_client.handle, &s_sub_client.conn_opts)) != MQTTCLIENT_SUCCESS)
    {
        printf("Failed to connect, return code %d\n", rc);
        goto destroy_exit;
    }

    printf("Subscribing to topic %s\nfor client %s using QoS%d\n\n"
           "Press Q<Enter> to quit\n\n", s_sub_client.topic, s_sub_client.client_id, s_sub_client.qos);
    if ((rc = MQTTClient_subscribe(s_sub_client.handle, s_sub_client.topic, s_sub_client.qos)) != MQTTCLIENT_SUCCESS)
    {
    	printf("Failed to subscribe, return code %d\n", rc);
    	rc = EXIT_FAILURE;
    }
    else
    {
    	int ch;
    	do
    	{
        	ch = getchar();
    	} while (ch!='Q' && ch != 'q');
    }

    MQTTClient_unsubscribe(s_sub_client.handle, s_sub_client.topic);
    MQTTClient_disconnect(s_sub_client.handle, s_sub_client.timeout);
destroy_exit:
    MQTTClient_destroy(&s_sub_client.handle);
    pthread_exit(NULL);
}

void *pubClient(void *threadid)
{
    long tid;
    tid = (long)threadid;
    int count = 0;
    printf("Hello World! It's me, thread #%ld!---------------------------------------->\n", tid);
    
    //声明消息token
    MQTTClient_deliveryToken token;
    int rc;
    //使用参数创建一个client，并将其赋值给之前声明的client
    MQTTClient_create(&s_pub_client.handle, s_pub_client.server_addr, s_pub_client.client_id,
    MQTTCLIENT_PERSISTENCE_NONE, NULL);
    s_pub_client.conn_opts.keepAliveInterval = 20;
    s_pub_client.conn_opts.cleansession = 1;

    //使用MQTTClient_connect将client连接到服务器，使用指定的连接选项。成功则返回MQTTCLIENT_SUCCESS
    if ((rc = MQTTClient_connect(s_pub_client.handle, &s_pub_client.conn_opts)) != MQTTCLIENT_SUCCESS)
    {
        printf("Failed to connect, return code %d\n", rc);
        exit(EXIT_FAILURE);
    }
    s_pub_client.pub_msg.payload = PAYLOAD;
    s_pub_client.pub_msg.payloadlen = strlen(PAYLOAD);
    s_pub_client.pub_msg.qos = s_pub_client.qos;
    s_pub_client.pub_msg.retained = 0;
    
    while(CONNECT){
        MQTTClient_publishMessage(s_pub_client.handle, s_pub_client.topic, &s_pub_client.pub_msg, &token);
        printf("Waiting for up to %d seconds for publication of %s\n"   \
        "on topic %s for s_pub_client.handle with ClientID: %s\n",               \
        (int)(s_pub_client.timeout/1000), PAYLOAD, s_pub_client.topic, s_pub_client.client_id);

        rc = MQTTClient_waitForCompletion(s_pub_client.handle, token, s_pub_client.timeout);
        printf("Message with delivery token %d delivered_callback\n", token);
        usleep(3000000L);
    }

    MQTTClient_disconnect(s_pub_client.handle, 10000);
    MQTTClient_destroy(&s_pub_client.handle);
}

void signal_handler(int signum)
{
    if(signum == SIGINT) {
        printf("\nSIGINT signal capture...\nStart to kill connection... \n");

        if(s_sub_client.handle) {
            int rc;
            if (rc = MQTTClient_unsubscribe(s_sub_client.handle, s_sub_client.topic) != MQTTCLIENT_SUCCESS)
            {
            	printf("Failed to unsubscribe, return code %d\n", rc);
            	rc = EXIT_FAILURE;
            } else {
                printf("Unsubscribe topic : %s success\n", s_sub_client.topic);
            }
            printf("Sub Client handle pointer = %p\n", s_sub_client.handle);
            MQTTClient_disconnect(s_sub_client.handle, 10000);
            MQTTClient_destroy(&s_sub_client.handle);
        }

        if(s_pub_client.handle) {
            printf("Pub Client handle pointer = %p\n", s_pub_client.handle);
            MQTTClient_disconnect(s_pub_client.handle, 10000);
            MQTTClient_destroy(&s_pub_client.handle);
        }
        
        printf("OK\n");

        exit(1);
    }
}

int main(int argc, char* argv[])
{
    pthread_t threads[NUM_THREADS];

    signal(SIGINT, signal_handler);

    /* 开启 MQTT 客户端订阅线程 */
    if(0 != pthread_create(&threads[0], NULL, subClient, (void *)0)){
        printf("pthread_create() ERROR!\n");
    }

    /* 开启 MQTT 客户端发布线程 */
    if(0 != pthread_create(&threads[1], NULL, pubClient, (void *)1)){
        printf("pthread_create() ERROR!\n");
    }

    pthread_exit(NULL);
}
```

## 3. MQTTAsync （依赖libpaho-mqtt3a） demo 的编译和运行
**代码功能说明**
- 包含一个订阅者线程，基于示例 `MQTTAsync_subscribe.c` 更改：
    1. 连接服务器
    2. 订阅主题
    3. 接收消息
    4. 打印消息
    5. 接收到 SIGINT 信号后断开连接
- 包含一个发布者线程，基于示例 `MQTTAsync_publish.c` 更改：
    1. 连接服务器
    2. 发布消息
    3. 打印消息
    4. 接收到 SIGINT 信号后断开连接

### 2.1. 编译操作
- 编译需要依赖线程库（指定 -pthread ）以及编译好的 MQTT 库（指定 -lpaho-mqtt3c）；
- 编译需要指定头文件路径；
编译命令如下，也可使用 Makefile 编译：
```bash
gcc -o async_test async_test.c  paho.mqtt.c/src/MQTTAsync.h -pthread -lpaho-mqtt3c
```

### 2.2. 运行结果