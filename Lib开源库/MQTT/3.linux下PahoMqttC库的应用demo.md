# 3.linux 下 PahoMqttC 库的应用 demo

## 1. Paho.Mqtt.C 库中的示例介绍
以下 demo 都是基于已有的 Paho.Mqtt.C 库中的示例更改而来，库中位于 `paho.mqtt.c/src/samples` 文件夹，共提供了以下几个示例：
```bash
.
├── MQTTAsync_publish.c     # 异步消息发布：使用 MQTTAsync 接口发送单条MQTT消息，不阻塞主线程
├── MQTTAsync_publish_time.c    # 带过期时间的异步消息发布：周期性发布消息（如每秒1条），展示异步定时任务实现。
├── MQTTAsync_subscribe.c       # 异步消息订阅：订阅主题并异步接收消息（通过回调函数处理到达的消息）
├── MQTTClient_publish_async.c  # 伪异步发布：使用同步API但通过线程模拟异步行为（非官方推荐方式）
├── MQTTClient_publish.c        # 基础同步发布：阻塞式发送消息，等待服务器确认后继续执行。
├── MQTTClient_subscribe.c      # 同步订阅：阻塞线程等待消息到达（通常配合循环使用）。
├── paho_c_pub.c                # 命令行发布工具：类似 mosquitto_pub，支持参数化主题/消息/QoS发布。
├── paho_cs_pub.c               # 加密发布示例：通过SSL/TLS加密通道发布消息（需配置证书）。
├── paho_cs_sub.c               # 加密订阅示例：通过SSL/TLS加密通道订阅消息。
├── paho_c_sub.c                # 命令行订阅工具：类似 mosquitto_sub，持续打印接收到的消息。
└── pubsub_opts.c               # 参数解析模块：统一处理命令行参数（如Broker地址、主题、QoS等）。
```

## 2. MQTTClient（依赖libpaho-mqtt3c） demo 的编译和运行
**代码功能说明**
- 包含一个订阅者线程，基于示例 `MQTTClient_subscribe.c` 更改：
    1. 连接服务器
    2. 订阅主题
    3. 接收消息
    4. 打印消息
    5. 接收到 SIGINT 信号后断开连接
- 包含一个发布者线程，基于示例 `MQTTClient_publish_async.c` 更改：
    1. 连接服务器
    2. 发布消息
    3. 打印消息
    4. 接收到 SIGINT 信号后断开连接

### 2.1. 编译操作
- 编译需要依赖线程库（指定 -pthread ）以及编译好的 MQTT 库（指定 -lpaho-mqtt3c）；
- 编译需要指定头文件路径；
编译命令如下，也可使用 Makefile 编译：
```bash
gcc -o test test.c  paho.mqtt.c/src/MQTTClient.h -pthread -lpaho-mqtt3c
```

### 2.2. 运行结果
运行结果如下：
```bash
root@light-14-prd1:~/github/paho_mqtt_c# ./test 
Hello World! It's me, thread #0!---------------------------------------->
Hello World! It's me, thread #1!---------------------------------------->
Subscribing to topic sub01
for client aaabbbccc_sub using QoS1

Press Q<Enter> to quit

Waiting for up to 10 seconds for publication of Hello Man, Can you see me ?!
on topic pub01 for s_pub_client.handle with ClientID: aaabbbccc_pub
Message with delivery token 1 delivered_callback
Waiting for up to 10 seconds for publication of Hello Man, Can you see me ?!
on topic pub01 for s_pub_client.handle with ClientID: aaabbbccc_pub
Message with delivery token 2 delivered_callback
^C
SIGINT signal capture...
Start to kill connection... 
Unsubscribe topic : sub01 success
Sub Client handle pointer = 0x7f2b4c020328
Pub Client handle pointer = 0x7f2b44000b78
OK
```

### 2.3. demo 源码
```c
/* test.c */
#include <pthread.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <signal.h>
#include "MQTTClient.h"

#if !defined(WIN32)
#include <unistd.h>
#else
#include <windows.h>
#endif

#define NUM_THREADS 2

typedef struct {
    MQTTClient handle;
    MQTTClient_connectOptions conn_opts ;
    char server_addr[128];    /* 服务器地址 */
    char client_id[64];
    char topic[64];
    char username[64];
    char password[64];
    int qos;
    int timeout;

    MQTTClient_message pub_msg;
    /* data */
}MQTT_client;

MQTT_client s_sub_client = {
    NULL,
    MQTTClient_connectOptions_initializer,   //连接初始化
    "mqtt://10.49.1.233:1883",  //更改此处地址
    "aaabbbccc_sub",            //更改此处客户端ID
    "sub01",                  //更改发送的话题
    "sub_user", //用户名
    "jim777",   //密码
    .qos = 1,   //QOS
    .timeout = 10000L
};

MQTT_client s_pub_client = {
    NULL,
    MQTTClient_connectOptions_initializer,   //连接初始化
    "mqtt://10.49.1.233:1883",  //更改此处地址
    "aaabbbccc_pub",            //更改此处客户端ID
    "pub01",                  //更改发送的话题
    "pub_user", //用户名
    "jim777",   //密码
    .qos = 1,   //QOS
    .timeout = 10000L,
    .pub_msg = MQTTClient_message_initializer
};

#define PAYLOAD "Hello Man, Can you see me ?!" //默认发送字符串

int CONNECT = 1;
volatile MQTTClient_deliveryToken deliveredtoken;

/* 定义传输成功回调函数 */
void delivered_callback(void *context, MQTTClient_deliveryToken dt)
{
    printf("Message with token value %d delivery confirmed\n", dt);
    deliveredtoken = dt;
}

/* 定义接收消息到达回调函数 */
int  msgarrvd_callback(void *context, char *topicName, int topicLen, MQTTClient_message *message)
{
    int i;
    char* payloadptr;

    printf("Message arrived\n");
    printf(" topic: %s\n", topicName);
    printf(" message: ");

    payloadptr = message->payload;
    if(strcmp(payloadptr, "out") == 0){
        printf(" \n out!!");
        CONNECT = 0;
    }

    for(i=0; i<message->payloadlen; i++)
    {
        putchar(*payloadptr++);
    }
    printf("\n");

    MQTTClient_freeMessage(&message);
    MQTTClient_free(topicName);
    return 1;
}

/* 连接失败回调函数 */
void connlost_callback(void *context, char *cause)
{
    printf("\nConnection lost\n");
    printf(" cause: %s\n", cause);
}

/* 订阅测试程序 */
void *subClient(void *threadid)
{
    long tid;
    tid = (long)threadid;
    printf("Hello World! It's me, thread #%ld!---------------------------------------->\n", tid);

    int rc;
    int ch;

    if ((rc = MQTTClient_create(&s_sub_client.handle, s_sub_client.server_addr, s_sub_client.client_id,
        MQTTCLIENT_PERSISTENCE_NONE, NULL)) != MQTTCLIENT_SUCCESS)
    {
        printf("Failed to create client, return code %d\n", rc);
        pthread_exit(NULL) ;
    }

    
    if ((rc = MQTTClient_setCallbacks(s_sub_client.handle, NULL, connlost_callback, msgarrvd_callback, delivered_callback)) != MQTTCLIENT_SUCCESS)
    {
        printf("Failed to set callbacks, return code %d\n", rc);
        goto destroy_exit;
    }

    s_sub_client.conn_opts.keepAliveInterval = 20;
    s_sub_client.conn_opts.cleansession = 1;
    if ((rc = MQTTClient_connect(s_sub_client.handle, &s_sub_client.conn_opts)) != MQTTCLIENT_SUCCESS)
    {
        printf("Failed to connect, return code %d\n", rc);
        goto destroy_exit;
    }

    printf("Subscribing to topic %s\nfor client %s using QoS%d\n\n"
           "Press Q<Enter> to quit\n\n", s_sub_client.topic, s_sub_client.client_id, s_sub_client.qos);
    if ((rc = MQTTClient_subscribe(s_sub_client.handle, s_sub_client.topic, s_sub_client.qos)) != MQTTCLIENT_SUCCESS)
    {
    	printf("Failed to subscribe, return code %d\n", rc);
    	rc = EXIT_FAILURE;
    }
    else
    {
    	int ch;
    	do
    	{
        	ch = getchar();
    	} while (ch!='Q' && ch != 'q');
    }

    MQTTClient_unsubscribe(s_sub_client.handle, s_sub_client.topic);
    MQTTClient_disconnect(s_sub_client.handle, s_sub_client.timeout);
destroy_exit:
    MQTTClient_destroy(&s_sub_client.handle);
    pthread_exit(NULL);
}

void *pubClient(void *threadid)
{
    long tid;
    tid = (long)threadid;
    int count = 0;
    printf("Hello World! It's me, thread #%ld!---------------------------------------->\n", tid);
    
    //声明消息token
    MQTTClient_deliveryToken token;
    int rc;
    //使用参数创建一个client，并将其赋值给之前声明的client
    MQTTClient_create(&s_pub_client.handle, s_pub_client.server_addr, s_pub_client.client_id,
    MQTTCLIENT_PERSISTENCE_NONE, NULL);
    s_pub_client.conn_opts.keepAliveInterval = 20;
    s_pub_client.conn_opts.cleansession = 1;

    //使用MQTTClient_connect将client连接到服务器，使用指定的连接选项。成功则返回MQTTCLIENT_SUCCESS
    if ((rc = MQTTClient_connect(s_pub_client.handle, &s_pub_client.conn_opts)) != MQTTCLIENT_SUCCESS)
    {
        printf("Failed to connect, return code %d\n", rc);
        exit(EXIT_FAILURE);
    }
    s_pub_client.pub_msg.payload = PAYLOAD;
    s_pub_client.pub_msg.payloadlen = strlen(PAYLOAD);
    s_pub_client.pub_msg.qos = s_pub_client.qos;
    s_pub_client.pub_msg.retained = 0;
    
    while(CONNECT){
        MQTTClient_publishMessage(s_pub_client.handle, s_pub_client.topic, &s_pub_client.pub_msg, &token);
        printf("Waiting for up to %d seconds for publication of %s\n"   \
        "on topic %s for s_pub_client.handle with ClientID: %s\n",               \
        (int)(s_pub_client.timeout/1000), PAYLOAD, s_pub_client.topic, s_pub_client.client_id);

        rc = MQTTClient_waitForCompletion(s_pub_client.handle, token, s_pub_client.timeout);
        printf("Message with delivery token %d delivered_callback\n", token);
        usleep(3000000L);
    }

    MQTTClient_disconnect(s_pub_client.handle, 10000);
    MQTTClient_destroy(&s_pub_client.handle);
}

void signal_handler(int signum)
{
    if(signum == SIGINT) {
        printf("\nSIGINT signal capture...\nStart to kill connection... \n");

        if(s_sub_client.handle) {
            int rc;
            if (rc = MQTTClient_unsubscribe(s_sub_client.handle, s_sub_client.topic) != MQTTCLIENT_SUCCESS)
            {
            	printf("Failed to unsubscribe, return code %d\n", rc);
            	rc = EXIT_FAILURE;
            } else {
                printf("Unsubscribe topic : %s success\n", s_sub_client.topic);
            }
            printf("Sub Client handle pointer = %p\n", s_sub_client.handle);
            MQTTClient_disconnect(s_sub_client.handle, 10000);
            MQTTClient_destroy(&s_sub_client.handle);
        }

        if(s_pub_client.handle) {
            printf("Pub Client handle pointer = %p\n", s_pub_client.handle);
            MQTTClient_disconnect(s_pub_client.handle, 10000);
            MQTTClient_destroy(&s_pub_client.handle);
        }
        
        printf("OK\n");

        exit(1);
    }
}

int main(int argc, char* argv[])
{
    pthread_t threads[NUM_THREADS];

    signal(SIGINT, signal_handler);

    /* 开启 MQTT 客户端订阅线程 */
    if(0 != pthread_create(&threads[0], NULL, subClient, (void *)0)){
        printf("pthread_create() ERROR!\n");
    }

    /* 开启 MQTT 客户端发布线程 */
    if(0 != pthread_create(&threads[1], NULL, pubClient, (void *)1)){
        printf("pthread_create() ERROR!\n");
    }

    pthread_exit(NULL);
}
```

## 3. MQTTAsync demo 的编译和运行
**代码功能说明**
- 包含一个订阅者、发布者线程，依赖于 libpaho-mqtt3a 或 libpaho-mqtt3as ，基于示例 `MQTTAsync_subscribe.c` 和 `MQTTAsync_publish.c` 更改，功能包括：
    1. 连接服务器；
    2. 订阅主题；
    3. 接收打印订阅主题的消息；
    4. 循环线程检测连接状态：
        - 在连接正常时，周期发送发布主题的消息；
        - 连接异常时，重新建立连接；
    5. 接收到 SIGINT （键盘 CTRL + C）信号后，取消订阅并断开连接。

### 2.1. 编译操作
- 编译需要依赖线程库（指定 -pthread ）以及编译好的 MQTT 库（指定 -lpaho-mqtt3a 或 -lpaho-mqtt3as）；
- 如果需要使用 ssl 加密，需要修改服务器地址为 `mqtts://10.49.1.233:8883` ，并开启对应的 ssl 配置；
- 使用 ssl 加密连接时，
- 编译需要指定头文件路径；
编译命令如下，也可使用 Makefile 编译：
```bash
gcc -o async_test async_test.c  paho.mqtt.c/src/MQTTAsync.h -pthread -lpaho-mqtt3c
```

### 2.2. 运行结果
运行结果如下：
```bash
root@light-14-prd1:~/github/paho_mqtt_c# ./async_test 
Hello World! It's me, thread #0!---------------------------------------->
onConnect() :: Successful connection
onConnect() :: Subscribing to topic sub01 for client aaabbbccc_sub using QoS 1

Press Q<Enter> to quit

onSubscribe() :: Subscribe succeeded
# 后面开始周期发送消息
delivered_callback() :: Message with token value 2 delivery confirmed
onSend() :: Pulished success
delivered_callback() :: Message with token value 3 delivery confirmed
onSend() :: Pulished success
# 现在将 MQTT 服务器停止
Connection lost
Reconnecting...
onConnectFailure() :: Connect failed, rc -1, Failure
onConnectFailure() :: Connect failed, rc -1, Failure
onConnectFailure() :: Connect failed, rc -1, Failure

# 这里将 MQTT 服务器重新运行起来
onConnect() :: Successful connection
onConnect() :: Subscribing to topic sub01 for client aaabbbccc_sub using QoS 1

Press Q<Enter> to quit

onSubscribe() :: Subscribe succeeded
delivered_callback() :: Message with token value 2 delivery confirmed
onSend() :: Pulished success
delivered_callback() :: Message with token value 3 delivery confirmed
onSend() :: Pulished success
# 使用 ctrl+c 发送信号，开始停止程序
^C
SIGINT signal capture...
onSend() :: Pulished success
Connect disconnect : success
Client handle pointer = 0x7f4028020408
Warning: Client still connected!
onDisconnect() :: Successful disconnection
OK
```

### 2.3. demo 源码
```c
#include <pthread.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <signal.h>
#include "MQTTAsync.h"

#if !defined(WIN32)
#include <unistd.h>
#else
#include <windows.h>
#endif

#if defined(_WRS_KERNEL)
#include <OsWrapper.h>
#endif

#define NUM_THREADS 2

typedef struct {
    MQTTAsync handle;
    MQTTAsync_connectOptions conn_opts ;
    MQTTAsync_disconnectOptions disc_opts;
    MQTTAsync_responseOptions rsp_opts;
    char server_addr[128];    /* 服务器地址 */
    char client_id[64];
    char sub_topic[64];
    char pub_topic[64];
    char username[64];
    char password[64];
    int qos;
    int timeout;

    MQTTAsync_message pub_msg;

    int disc_finished;
    int subscribed;
    int finished;
    /* data */
}MQTT_async;

MQTT_async s_client = {
    NULL,
    MQTTAsync_connectOptions_initializer,   //连接初始化
    MQTTAsync_disconnectOptions_initializer,
    MQTTAsync_responseOptions_initializer,
    "mqtt://10.49.1.233:1883",  //更改此处地址
    "aaabbbccc_sub",            //更改此处客户端ID
    "sub01",                  //更改发送的话题
    "pub01",                  //更改发送的话题
    "sub_user", //用户名
    "jim777",   //密码
    .qos = 1,   //QOS
    .timeout = 10000L,
    .pub_msg = MQTTAsync_message_initializer
};

#define PAYLOAD "Hello Man, Can you see me ?!" //默认发送字符串

void onDisconnectFailure(void* context, MQTTAsync_failureData* response)
{
    MQTT_async *client = (MQTT_async *)context;

	printf("onDisconnectFailure() :: Disconnect failed, rc %d, %s\n", response->code, MQTTAsync_strerror(response->code));
	client->disc_finished = 1;
}

void onDisconnect(void* context, MQTTAsync_successData* response)
{
    MQTT_async *client = (MQTT_async *)context;

	printf("onDisconnect() :: Successful disconnection\n");
		if(client == NULL) printf("onDisconnect() :: 111\n");
	client->disc_finished = 1;
}

void onSubscribe(void* context, MQTTAsync_successData* response)
{
    MQTT_async *client = (MQTT_async *)context;

	printf("onSubscribe() :: Subscribe succeeded\n");
	client->subscribed = 1;
}

void onSubscribeFailure(void* context, MQTTAsync_failureData* response)
{
    MQTT_async *client = (MQTT_async *)context;

	printf("onSubscribeFailure() :: Subscribe failed, rc %d, %s\n", response->code, MQTTAsync_strerror(response->code));
	client->finished = 1;
}


void onConnectFailure(void* context, MQTTAsync_failureData* response)
{
    MQTT_async *client = (MQTT_async *)context;

	printf("onConnectFailure() :: Connect failed, rc %d, %s\n", response->code, MQTTAsync_strerror(response->code));
	client->finished = 1;
}

void onConnect(void* context, MQTTAsync_successData* response)
{
	MQTT_async *client = (MQTT_async *)context;
	int rc;

	printf("\nonConnect() :: Successful connection\n");
	printf("onConnect() :: Subscribing to topic %s for client %s using QoS %d\n\n", client->sub_topic, client->client_id, client->qos);
	client->rsp_opts.onSuccess = onSubscribe;
	client->rsp_opts.onFailure = onSubscribeFailure;
	client->rsp_opts.context = client;
	if ((rc = MQTTAsync_subscribe(client->handle, client->sub_topic, client->qos, &client->rsp_opts)) != MQTTASYNC_SUCCESS)
	{
		printf("onConnect() :: Failed to start subscribe, return code %d, %s\n", rc, MQTTAsync_strerror(rc));
		client->finished = 1;
	}
}

void onSend(void* context, MQTTAsync_successData* response)
{
	MQTT_async *client = (MQTT_async *)context;

	printf("onSend() :: Pulished success\n");
}

void onSendFailure(void* context, MQTTAsync_failureData* response)
{
	MQTT_async *client = (MQTT_async *)context;

	printf("onSend() :: Pulished failed, rc %d, %s\n", response->code, MQTTAsync_strerror(response->code));
}

/* 定义传输成功回调函数 */
void delivered_callback(void *context, MQTTAsync_token token)
{
    printf("delivered_callback() :: Message with token value %d delivery confirmed\n", token);
}

/* 定义接收消息到达回调函数 */
int msgarrvd_callback(void *context, char *topicName, int topicLen, MQTTAsync_message *message)
{
    printf("\nMessage arrived\n");
    printf("     topic: %s\n", topicName);
    printf("   message: %.*s\n", message->payloadlen, (char*)message->payload);
    MQTTAsync_freeMessage(&message);
    MQTTAsync_free(topicName);
    return 1;
}

void mqtt_set_connect(void)
{
	int rc;
	s_client.conn_opts.keepAliveInterval = 20;
	s_client.conn_opts.cleansession = 1;
	s_client.conn_opts.onSuccess = onConnect;
	s_client.conn_opts.onFailure = onConnectFailure;
	s_client.conn_opts.context = &s_client;

    /* 如果需要使用 ssl 加密，需要开启以下注释，且编译时指定成 -lpaho-mqtt3as ， */
    // MQTTAsync_SSLOptions ssl_opts = MQTTAsync_SSLOptions_initializer;
    // ssl_opts.enableServerCertAuth = 0;
    // s_client.conn_opts.ssl = &ssl_opts;

	if ((rc = MQTTAsync_connect(s_client.handle, &s_client.conn_opts)) != MQTTASYNC_SUCCESS)
	{
		printf("Failed to start connect, %d, %s\n", rc, MQTTAsync_strerror(rc));
		rc = EXIT_FAILURE;
		MQTTAsync_destroy(&s_client.handle);
	}
}

/* 连接失败回调函数 */
void connlost_callback(void *context, char *cause)
{
	MQTT_async *client = (MQTT_async *)context;
	int rc;

	printf("\nConnection lost\n");
	if (cause)
		printf("     cause: %s\n", cause);

	printf("Reconnecting...\n");
	mqtt_set_connect();
}

void signal_handler(int signum)
{
    if(signum == SIGINT) {
        printf("\nSIGINT signal capture...\n");

        if(s_client.handle) {
            int rc;
            if (rc = MQTTAsync_unsubscribe(s_client.handle, s_client.sub_topic, &s_client.rsp_opts) != MQTTASYNC_SUCCESS)
            {
            	printf("Failed to unsubscribe, return code %d\n", rc);
            	rc = EXIT_FAILURE;
            } else {
				if (rc = MQTTAsync_waitForCompletion(s_client.handle, s_client.rsp_opts.token, 1000) == MQTTASYNC_SUCCESS)
				{
					printf("Connect disconnect : success\n");
				}
    		}
            printf("Client handle pointer = %p\n", s_client.handle);

            s_client.disc_opts.onSuccess = onDisconnect;
	        s_client.disc_opts.onFailure = onDisconnectFailure;
			s_client.disc_opts.context = &s_client;
	        if ((rc = MQTTAsync_disconnect(s_client.handle, &s_client.disc_opts)) != MQTTASYNC_SUCCESS)
	        {
	        	printf("Failed to start disconnect, return code %d\n", rc);
	        	rc = EXIT_FAILURE;
	        } 

			/* 等待资源回收 */
			while (MQTTAsync_isConnected(s_client.handle) != 0)
			{
				printf("Warning: Client still connected!\n");
				usleep(1);
			}
            MQTTAsync_destroy(&s_client.handle);
        }
        
        printf("OK\n");

        exit(1);
    }
}

/* 订阅测试程序 */
void *mqtt_async_thread(void *threadid)
{
    long tid;
    tid = (long)threadid;
    printf("Hello World! It's me, thread #%ld!---------------------------------------->\n", tid);

    int rc;
    int ch;

	if ((rc = MQTTAsync_create(&s_client.handle, s_client.server_addr, s_client.client_id, MQTTCLIENT_PERSISTENCE_NONE, NULL))
			!= MQTTASYNC_SUCCESS)
	{
		printf("Failed to create client, return code %d, %s\n", rc, MQTTAsync_strerror(rc));
		rc = EXIT_FAILURE;
		pthread_exit(NULL);
	}

	if ((rc = MQTTAsync_setCallbacks(s_client.handle, &s_client, connlost_callback, msgarrvd_callback, delivered_callback)) != MQTTASYNC_SUCCESS)
	{
		printf("Failed to set callbacks, return code %d, %s\n", rc, MQTTAsync_strerror(rc));
		rc = EXIT_FAILURE;
		MQTTAsync_destroy(&s_client.handle);
	}

	mqtt_set_connect();

	while (!s_client.subscribed && !s_client.finished) {
		#if defined(_WIN32)
			Sleep(100);
		#else
			usleep(100000L);
		#endif
    }

	if (s_client.finished)
		pthread_exit(NULL);

	while(1) {
		sleep(10);

		if (MQTTAsync_isConnected(s_client.handle) != 0) {
			s_client.rsp_opts.context = &s_client;
			s_client.rsp_opts.onSuccess = onSend;
			s_client.rsp_opts.onFailure = onSendFailure;
			s_client.pub_msg.payload = PAYLOAD;
			s_client.pub_msg.payloadlen = strlen(PAYLOAD);
    		s_client.pub_msg.qos = s_client.qos;
    		s_client.pub_msg.retained = 0;
			if ((rc = MQTTAsync_sendMessage(s_client.handle, s_client.pub_topic, &s_client.pub_msg, &s_client.rsp_opts)) != MQTTASYNC_SUCCESS) {
				printf("Failed to start sendMessage, return code %d\n", rc);
			}
		} else {
			mqtt_set_connect();
		}
		
	}

    pthread_exit(NULL);
}

int main(int argc, char* argv[])
{
    pthread_t t_mqtt;

    signal(SIGINT, signal_handler);

    /* 开启 MQTT 客户端订阅线程 */
    if(0 != pthread_create(&t_mqtt, NULL, mqtt_async_thread, (void *)0)){
        printf("pthread_create() ERROR!\n");
    }

	pthread_join(t_mqtt, NULL);
	return 0;
}
```