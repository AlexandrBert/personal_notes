# stm32 标准库之串口 uart 使用
文章主要目的是利用 stm32 芯片的 uart 接口，实现：
- 串口的不定长报文接收；
- 以十六进制打印或字符打印：
- printf() 标准函数重定向；

以下实例的开发环境如下：
- 应用芯片为 STM32F103C8T6 ；
- MDK-ARM 版本为 v5.34.0 ；
- 标准库版本为 v3.6.0 ；
- FreeRTOS 库版本为 v202406.01-LTS ；
- 串口为 USART1 ；
    - 串口引脚为 PA9 和 PA10 ；
    - 串口波特率为 115200 ；
    - 串口数据位为 8 位；
    - 串口停止位为 1 位；
    - 串口校验位为无。

## 1. 串口接收不定长报文
### 1.1. UART 初始化
串口初始化函数 `uart_init` 主要包括外设时钟初始化、GPIO 输入输出模式设置和串口初始化。最后，使能串口：
```c
void uart_init(void)
{
    RCC_Configuration();
    GPIO_Configuration();
    UART1_Configuration();
    NVIC_Configuration();
    USART_Cmd(USART1, ENABLE);  /* 使能串口 */
}
```
#### 1.1.1 外设时钟初始化
首先，需要使能外设时钟，这里使能 GPIOA 和 USART1 的系统时钟：
```c
void RCC_Configuration(void)
{
    /* Enable GPIO clock */
    RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOA | RCC_APB2Periph_USART1, ENABLE);
}
```

#### 1.1.2 GPIO 输入输出模式设置
使能外设始终后，设置 GPIO 的输入输出模式，这里设置 PA9 和 PA10 分别设置为复用推挽输出和浮空输入模式：
```c
/* uart.c 中实现 */
#define USART1_RX_GPIO    GPIOA
#define USART1_RX_PIN    GPIO_Pin_10
#define USART1_RX_GPIO_MODE   GPIO_Mode_IN_FLOATING
#define USART1_TX_GPIO    GPIOA
#define USART1_TX_PIN    GPIO_Pin_9
#define USART1_TX_GPIO_MODE   GPIO_Mode_AF_PP
#define UART_GPIO_SPEED  GPIO_Speed_50MHz

static void GPIO_Configuration(void)
{
    GPIO_InitTypeDef GPIO_InitStructure;

    // USART1_TX
    GPIO_InitStructure.GPIO_Pin = USART1_TX_PIN;        // 选择要使用的I/O引脚,此处选择PA9引脚
    GPIO_InitStructure.GPIO_Speed = UART_GPIO_SPEED;    // 设置引脚的输出速度为50MHz
    GPIO_InitStructure.GPIO_Mode = USART1_TX_GPIO_MODE; // 设置引脚输出模式为复用推挽输出模式
    GPIO_Init(USART1_TX_GPIO, &GPIO_InitStructure);

    // USART1_RX
    GPIO_InitStructure.GPIO_Pin = USART1_RX_PIN;        // 选择要使用的I/O引脚,此处选择PA10引脚
    GPIO_InitStructure.GPIO_Mode = USART1_RX_GPIO_MODE; // 设置引脚输入模式为浮空输入模式
    GPIO_Init(USART1_RX_GPIO, &GPIO_InitStructure);
}
```

#### 1.1.3. 串口初始化
设置好 GPIO 后，接下来设置串口的参数，包括波特率、数据位、停止位、校验位等：
```c
static void UART1_Configuration(void)
{
    USART_InitTypeDef USART_InitStructure;
    // USART1 配置
    USART_InitStructure.USART_BaudRate = 115200;                                    // 设置波特率为115200
    USART_InitStructure.USART_WordLength = USART_WordLength_8b;                     // 数据位占8位
    USART_InitStructure.USART_StopBits = USART_StopBits_1;                          // 设置1位停止位
    USART_InitStructure.USART_Parity = USART_Parity_No;                             // 设置无校验
    USART_InitStructure.USART_HardwareFlowControl = USART_HardwareFlowControl_None; // 设置不采用硬件数据流控制
    USART_InitStructure.USART_Mode = USART_Mode_Rx | USART_Mode_Tx;                 // 设置为收/发模式
    USART_Init(USART1, &USART_InitStructure);                                       // 初始化串口1
    USART_ITConfig(USART1, USART_IT_RXNE, ENABLE);                                  // 开启 USART1 接收中断
}
```

#### 1.1.4. NVIC 中断优先级设置
设置好串口参数后，如果想要中断的方式接收数据，需要设置 NVIC 中断优先级，这里设置串口中断优先级为 7：
```c
static void NVIC_Configuration(void)
{
    NVIC_InitTypeDef NVIC_InitStructure;

    /* Configure the NVIC Preemption Priority Bits */
    NVIC_PriorityGroupConfig(NVIC_PriorityGroup_4);             /* 设置为0-15个全抢占优先级 */

    /* Enable the USARTy Interrupt */
    NVIC_InitStructure.NVIC_IRQChannel = USART1_IRQn;           /* 设置 USART1 中断 */
    /* 使用 FreeRTOS 时，其优先级数值建议大于 configMAX_SYSCALL_INTERRUPT_PRIORITY 设置的
     * 可控制的中断级别，否则在调用 freertos API 函数时可能会出错 */
    NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = 7;  
    NVIC_InitStructure.NVIC_IRQChannelSubPriority = 0;
    NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE;
    NVIC_Init(&NVIC_InitStructure);
}
```

### 1.2. 串口中断处理函数
在串口初始化时，我们使能了串口接收中断，所以当串口接收到数据时，会触发中断，进入中断处理函数：
```c
/* 在 stm32f10x_it.h 中添加中断处理函数，在 stm32f10x_it.c 中调用串口接收处理函数 */
#include "uart.h"
void USART1_IRQHandler(void)
{
  UART1_IT_ReceiveHandler();
}

/* 在 uart.c 实现接收处理函数 */
void UART1_IT_ReceiveHandler(void)
{
  // 1. 检查接收中断产生
  if (USART_GetITStatus(USART1, USART_IT_RXNE) != RESET) {

    /* 记录接收时的 ticks */
    ulUart1RxTicks = xTaskGetTickCountFromISR();
    // 2. 读取接收到的数据
    uint8_t data = USART_ReceiveData(USART1);

    // 3. 将数据存储到接收缓冲区
    if (ucUart1RxCounter < UART1_RX_BUF_SIZE) {
        Uart1RxBuffer[ucUart1RxCounter++] = data;
    }

    // 4. 清除中断标志
    USART_ClearITPendingBit(USART1, USART_IT_RXNE);
  }
}
```

### 1.3. 串口应用程序
#### 1.3.1. 创建串口处理任务
```c
uint8_t ucUart1RxStart;             /* 开始接收标志 */
uint32_t ulUart1RxTicks;            /* 接收期间的tick标志 */
uint32_t ulUart1RxTimeout = 10;     /* 接收超时时间 */
__IO uint8_t ucUart1RxCounter;      /* 接收计数 */
uint8_t Uart1RxBuffer[UART1_RX_BUF_SIZE];  /* 接收缓冲区 */
/* uart 串口任务 */
void uart_task(void *parameter)
{
    while (1)
    {
        /* 使用有数据在接收时，判断接收更新的 tick 和当前 tick，如果接收 tick 不更新导致事件超过 10 ms，则代表接收到完整一帧 */
        if ((ucUart1RxCounter > 0) && (xTaskGetTickCount() - ulUart1RxTicks >= ulUart1RxTimeout))
        {
            // 处理接收到的数据（例如打印或解析）
            for (uint16_t i = 0; i < ucUart1RxCounter; i++)
            {
                printf("%02X ", Uart1RxBuffer[i]); // 以十六进制打印数据
            }
            printf("\n");
            // 重置接收状态
            ucUart1RxCounter = 0;
        }
        /* 给一定延迟，释放CPU */
        vTaskDelay(50);
    }
}
```

#### 1.3.2. 创建任务执行程序
创建串口任务后，在主程序中创建任务并启动 FreeRTOS 任务调度：
```c
int main(void)
{
    TaskHandle_t led_handle_t, uart_handle_t;
    NVIC_PriorityGroupConfig(NVIC_PriorityGroup_4);

    /* uart task */
    UART1_Init();
    xTaskCreate((TaskFunction_t)uart_task, "uart", 128, NULL, 2, &uart_handle_t);

    vTaskStartScheduler();
    while (1)
    {
    }
}
```

#### 1.3.3. 执行结果
执行程序烧写后，程序将会接收串口数据，并将接收到的数据以十六进制打印出来；

在电脑端使用串口助手发送十六进制数据，例如：`12 34 56 78 90`，程序将会接收到数据并打印出来：

### 1.4. 注意事项
#### 1.4.1. 调试常见问题
1. 如果程序无法进入中断，请检查 NVIC 中断优先级设置是否正确；
2. 如果程序接收到数据后，无法正确处理，请检查接收缓冲区大小是否足够，以及接收数据是否完整；
3. 善用 keil 的 debug 模式，通过查看寄存器状态，可以快速定位问题。




--------

## 2. 串口数据发送
### 2.1. 以十六进制发送串口数据
```c
/**
 * @brief 串口发送一个字节
 */
void UART_Send_Byte(USART_TypeDef *USARTx, uint8_t const Data)
{
    USART_SendData(USARTx, Data); // 把要发送的数据写进发送缓冲寄存器（自动清除TXE位）
    while (RESET == USART_GetFlagStatus(USARTx, USART_FLAG_TXE))
        ; // 等待发送数据缓冲区数据转移至移位寄存器
}
```

### 2.2. 串口发送字符串
```c
/**
 * @brief 串口发送一个字符串
 */
void UART_Send_String(USART_TypeDef *USARTx, char *buf, int len)
{
    int i;
    for (i = 0; i < len; i++)
        USART_SendData(USARTx, (uint16_t) * (buf + i));
}
```

------

## 3. 串口重定向 printf() 标准函数
主要是通过重定向 fputc() （或 __io_putchar()）函数实现 printf() 函数的串口输出，在 FreeRTOS 中，printf() 函数会调用 fputc() 函数，所以只需要重定向 fputc() 函数即可。
```c
#define UART_REDIRECTION_PRINTF 1

#if (UART_REDIRECTION_PRINTF == 1)
#ifdef __GNUC__
/* With GCC/RAISONANCE, small printf (option LD Linker->Libraries->Small printf
   set to 'Yes') calls __io_putchar() */
#define PUTCHAR_PROTOTYPE int __io_putchar(int ch)
#else
#define PUTCHAR_PROTOTYPE int fputc(int ch, FILE *f)
#endif /* __GNUC__ */

/**
 * @brief  Retargets the C library printf function to the USART.
 * @param  None
 * @retval None
 */
PUTCHAR_PROTOTYPE
{
    /* Place your implementation of fputc here */
    /* e.g. write a character to the USART */
    USART_SendData(USART1, (uint8_t)ch);

    /* Loop until the end of transmission */
    while (USART_GetFlagStatus(USART1, USART_FLAG_TC) == RESET)
    {
    }

    return ch;
}
#endif
```