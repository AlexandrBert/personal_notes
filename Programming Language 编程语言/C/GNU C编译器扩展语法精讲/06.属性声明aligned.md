# 属性声明：aligned 和 packed

## 1. 地址对齐：aligned
### 1.1. aligned 的使用
GNU C通过 __attribute__ 来声明 aligned 和 packed 属性，指定一个变量或类型的对齐方式。这两个属性用来告诉编译器：在给变量分配存储空间时，要按指定的地址对齐方式给变量分配地址。如果你想定义一个变量，在内存中以8字节地址对齐，就可以这样定义。

```c
int a __attribute__((aligned(8))); 
```

通过aligned属性，我们可以显式地指定变量a在内存中的地址对齐方式。aligned有一个参数，表示要按几字节对齐，使用时要注意，地址对齐的字节数必须是2的幂次方，否则编译就会出错。

一般情况下，当我们定义一个变量时，编译器会按照默认的地址对齐方式，来给该变量分配一个存储空间地址。如果该变量是一个int型数据，那么编译器就会按4字节或4字节的整数倍地址对齐；如果该变量是一个short型数据，那么编译器就会按2字节或2字节的整数倍地址对齐；如果是一个char类型的变量，那么编译器就会按照1字节地址对齐。

```c
int a=1;
int b=2;
char c1=3;
char c2=4;

int main(int argc, char *argv[])
{
    printf("a: %p\n", &a);
    printf("b: %p\n", &b);
    printf("c1: %p\n", &c1);
    printf("c2: %p\n", &c2);
    return 0;
}
```

编译运行结果如下：

```bash
a: 0x55edd8424010
b: 0x55edd8424014
c1: 0x55edd8424018
c2: 0x55edd8424019
```

通过运行结果我们可以看到，对于int型数据，其在内存中的地址都是以4字节或4字节整数倍对齐的。而char类型的数据，其在内存中是以1字节对齐的。变量c2就直接被分配到了c1变量的下一个存储单元，不用像int数据那样考虑4字节对齐。接下来，我们修改一下程序，指定变量c2按4字节对齐。

```c
int a=1;
int b=2;
char c1=3;
char c2 __attribute__((aligned(4))) =4;

int main(int argc, char *argv[])
{
    printf("a: %p\n", &a);
    printf("b: %p\n", &b);
    printf("c1: %p\n", &c1);
    printf("c2: %p\n", &c2);
    return 0;
}
```
运行结果如下：
```c
a: 0x55f45c875010
b: 0x55f45c875014
c1: 0x55f45c875018
c2: 0x55f45c87501c
```

通过运行结果可以看到，字符变量c2由于使用aligned属性声明按照4字节边界对齐，所以编译器不可能再给其分配0x55edd8424019 这个地址，因为这个地址不是按照4字节对齐的。编译器会空出3个存储单元，直接从 0x55f45c87501c 这个地址上给变量c2分配存储空间。

通过aligned属性声明，虽然可以显式地指定变量的地址对齐方式，但是也会因边界对齐造成一定的内存空洞，浪费内存资源。如在上面这个程序中，0x55edd8424019～0x55edd842401b 这三个地址上的存储单元就没有被使用。

虽然地址对齐会造成一定的内存空洞，但是这种对齐设置可以简化CPU和内存RAM之间的接口和硬件设计。一个32位的计算机系统，在CPU读取内存时，硬件设计上可能只支持4字节或4字节倍数对齐的地址访问，CPU每次向内存RAM读写数据时，一个周期可以读写4字节。如果我们把一个int型数据放在4字节对齐的地址上，那么CPU一次就可以把数据读写完毕；如果我们把一个int型数据放在一个非4字节对齐的地址上，那么CPU可能就要分两次才能把这个4字节大小的数据读写完毕。

为了配合计算机的硬件设计，编译器在编译程序时，对于一些基本数据类型，如int、char、short、float等，会按照其数据类型的大小进行地址对齐，按照这种地址对齐方式分配的存储地址，CPU一次就可以读写完毕。虽然边界对齐会造成一些内存空洞，浪费一些内存单元，但是在硬件上的设计却大大简化了。这也是编译器给我们定义的变量分配地址时，不同类型的变量按照不同字节数地址对齐的主要原因。

除了int、char、short、float这些基本类型数据，对于一些复合类型数据，也要满足地址对齐要求。

### 1.2. 结构体的对齐
结构体作为一种复合数据类型，编译器在给一个结构体变量分配存储空间时，不仅要考虑结构体内各个基本成员的地址对齐，还要考虑结构体整体的对齐。为了结构体内各个成员地址对齐，编译器可能会在结构体内填充一些空间；为了结构体整体对齐，编译器可能会在结构体的末尾填充一些空间。

下面我们定义一个结构体，结构体内定义int、char和short 3个成员，并打印结构体的大小和各个成员的地址。

```c
struct data
{
    char a;
    int b;
    short c;
};

int main(int argc, char *argv[])
{
    struct data s;
    printf("size: %ld\n", sizeof(s));
    printf("a: %p\n", &s.a);
    printf("b: %p\n", &s.b);
    printf("c: %p\n", &s.c);
    return 0;
}
```
编译运行结果如下：
```bash
size: 12
a: 0x7fff078fd06c
b: 0x7fff078fd070
c: 0x7fff078fd074
```
因为结构体的成员b需要4字节对齐，所以编译器在给成员a分配完1字节的存储空间后，会空出3字节，在满足4字节对齐的0x0028FF34地址处才给成员b分配4字节的存储空间。接着是short类型的成员c占据2字节的存储空间。三个结构体成员一共占据1+3+4+2=10字节的存储空间。根据结构体的对齐规则，结构体的整体对齐要按结构体所有成员中最大对齐字节数或其整数倍对齐，或者说结构体的整体长度要为其最大成员字节数的整数倍，如果不是整数倍则要补齐。因为结构体最大成员int为4字节，所以结构体要按4字节对齐，或者说结构体的整体长度要是4的整数倍，要在结构体的末尾补充2字节，最后结构体的大小为12字节。

结构体成员按不同的顺序排放，可能会导致结构体的整体长度不一样，我们修改一下上面的程序中的数据格式。
```c
struct data
{
    char a;
    short b;
    int c;
};
```
运行结果如下
```bash
size: 8
a: 0x7ffdb9693be0
b: 0x7ffdb9693be2
c: 0x7ffdb9693be4
```
你会发现，char型变量a和short型变量b，被分配在了结构体前4字节的存储空间中，而且都满足各自的地址对齐方式，整个结构体大小是8字节，只造成1字节的内存空洞。我们继续修改程序，让short型的变量b按4字节对齐。
```c
struct data
{
    char a;
    short b __attribute__((aligned(4)));
    int c;
};
```
运行结果为：
```bash
size: 12
a: 0x7ffe4c074a0c
b: 0x7ffe4c074a10
c: 0x7ffe4c074a14
```

你会发现，结构体的大小又重新变为12字节。这是因为，我们显式指定short变量以4字节地址对齐，导致变量a的后面填充了3字节空间。int型变量c也要4字节对齐，所以变量b的后面也填充了2字节，导致整个结构体的大小为12字节。

我们不仅可以显式指定结构体内某个成员的地址对齐，也可以显式指定整个结构体的对齐方式。
```c
struct data
{
    /* data */
    char a;
    short b;
    int c;
} __attribute__((aligned(16)));
```
运行结果如下:
```bash
size: 16
a: 0x7fff5641ad70
b: 0x7fff5641ad72
c: 0x7fff5641ad74
```

### 1.3. 编译器一定会按照aligned指定的方式对齐吗？
通过aligned属性，我们可以显式指定一个变量的对齐方式，编译器就一定会按照我们指定的大小对齐吗？非也！

我们通过这个属性声明，其实只是建议编译器按照这种大小地址对齐，但不能超过编译器允许的最大值。一个编译器，对每个基本数据类型都有默认的最大边界对齐字节数。如果超过了，则编译器只能按照它规定的最大对齐字节数来给变量分配地址，这种现象一般在嵌入式的交叉编译器中比较常见。（对ubuntu服务器自带的gcc测试未发现此情况，65536也可以正常对齐）

## 2. 属性声明：packed
### 2.1. packed 属性的使用
aligned属性一般用来增大变量的地址对齐，元素之间因为地址对齐会造成一定的内存空洞。而packed属性则与之相反，一般用来减少地址对齐，指定变量或类型使用最可能小的地址对齐方式。
```c
struct data
{
    char a;
    short b __attribute__((packed));
    int c __attribute__((packed));
};

int main(int argc, char *argv[])
{
    struct data s;
    printf("size: %ld\n", sizeof(s));
    printf("a: %p\n", &s.a);
    printf("b: %p\n", &s.b);
    printf("c: %p\n", &s.c);

    return 0;
}
```
运行结果如下：
```bash
size: 7
a: 0x7ffc02cd11d1
b: 0x7ffc02cd11d2
c: 0x7ffc02cd11d4
```
通过结果我们看到，结构体内各个成员地址的分配，使用最小1字节的对齐方式，没有任何内存空间的浪费，导致整个结构体的大小只有7字节。

这个特性在底层驱动开发中还是非常有用的。例如，你想定义一个结构体，封装一个IP控制器的各种寄存器，在ARM芯片中，每一个控制器的寄存器地址空间一般都是连续存在的。如果考虑数据对齐，则结构体内就可能有空洞，就和实际连续的寄存器地址不一致。使用packed可以避免这个问题，结构体的每个成员都紧挨着，依次分配存储地址，这样就避免了各个成员因地址对齐而造成的内存空洞。

也可以对整个结构体添加packed属性，这和分别对每个成员添加packed属性效果是一样的。修改结构体后，重新编译程序，运行结果和上面程序的运行结果相同：结构体的大小为7，结构体内各成员地址相同。
```c
struct data
{
    char a;
    short b;
    int c ;
}__attribute__((packed));
```

### 2.2. 内核中的aligned、packed声明
在Linux内核源码中，我们经常看到aligned和packed一起使用，即对一个变量或类型同时使用aligned和packed属性声明。这样做的好处是：既避免了结构体内各成员因地址对齐产生内存空洞，又指定了整个结构体的对齐方式。
```c
struct data
{
    char a;
    short b;
    int c ;
}__attribute__((packed, aligned(8)));

int main(int argc, char *argv[])
{
    struct data s;
    printf("size: %ld\n", sizeof(s));
    printf("a: %p\n", &s.a);
    printf("b: %p\n", &s.b);
    printf("c: %p\n", &s.c);

    return 0;
}
```
运行结果如下：
```bash
size: 8
a: 0x7ffe51bbd480
b: 0x7ffe51bbd481
c: 0x7ffe51bbd483
```

在上面的程序中，结构体data虽然使用了packed属性声明，结构体内所有成员所占的存储空间为7字节，但是我们同时使用了aligned(8)指定结构体按8字节地址对齐，所以编译器要在结构体后面填充1字节，这样整个结构体的大小就变为8字节，按8字节地址对齐。