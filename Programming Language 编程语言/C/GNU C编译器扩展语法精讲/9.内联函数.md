# 内联函数
内联函数相关的两个属性：noinline和always_inline。这两个属性的用途是告诉编译器，在编译时，对我们指定的函数内联展开或不展开。其使用方法如下。
```c
static inline __attribute__((noinline)) int func();
static inline __attribute__((always_inline)) int func();
```

一个使用inline声明的函数被称为内联函数，内联函数一般前面会有static和extern修饰。使用inline声明一个内联函数，和使用关键字register声明一个寄存器变量一样，只是建议编译器在编译时内联展开。使用关键字register修饰一个变量，只是建议编译器在为变量分配存储空间时，将这个变量放到寄存器里，这会使程序的运行效率更高。那么编译器会不会放呢？这得视具体情况而定，编译器要根据寄存器资源是否紧张、这个变量的类型及是否频繁使用来做权衡。

同样，当一个函数使用inline关键字修饰时，编译器在编译时一定会内联展开吗？也不一定。编译器也会根据实际情况，如函数体大小、函数体内是否有循环结构、是否有指针、是否有递归、函数调用是否频繁来做决定。如GCC编译器，一般是不会对函数做内联展开的，只有当编译优化等级开到-O2以上时，才会考虑是否内联展开。但是在我们使用noinline和always_inline对一个内联函数作显式属性声明后，编译器的编译行为就变得确定了：使用noinline声明，就是告诉编译器不要展开；使用always_inline属性声明，就是告诉编译器要内联展开。
## 1. 什么是内联函数
说起内联函数，又不得不说函数调用开销。一个函数在执行过程中，如果需要调用其他函数，则一般会执行下面的过程。

（1）保存当前函数现场。

（2）跳到调用函数执行。

（3）恢复当前函数现场。

（4）继续执行当前函数。

如有一个ARM程序，在main()函数中对一些数据进行处理，运算结果暂时保存在R0寄存器中。接着调用另外一个func()函数，调用结束后，返回main()函数继续处理数据。如果我们在func ()函数中要使用R0这个寄存器（用于保存函数的返回值），就会改变R0寄存器中的值，那么就篡改了main ()函数中的暂存运算结果。当我们返回main ()函数继续进行数据处理时，最后的结果肯定不正确。

那么怎么办呢？很简单，在跳到func()函数执行之前，先把R0寄存器的值保存到堆栈中，func()函数执行结束后，再将堆栈中的值恢复到R0寄存器，这样main()函数就可以继续执行了，就像什么事情都没有发生过一样。

这种方法被证明是可行的：现在的计算机系统，无论什么架构和指令集，一般都采用这种方法。这种方法虽然麻烦了点，但至少能解决问题，无非就是需要不断地保存现场、恢复现场，这就是函数调用带来的开销。

对于一般的函数调用，这种方法是没有问题的。但对于一些极端情况，例如，一个函数短小精悍，函数体内只有一行代码，在程序中被大量频繁地调用。如果每次调用，都不断地保存现场，执行时却发现函数只有一行代码，接着又要恢复现场，则来回折腾的开销比较大，性价比不高。这就和你去五星级酒店订个餐位吃饭一样：VIP包间、刀叉餐具、空调、免费的茶水和小菜，服务人员都准备好了，你到了之后只点了一碗面条，吃完之后抹嘴走人，而且一连好多天你都这么干，你说商家会不会对你有意见？

函数调用也是如此：有些函数短小精悍，而且调用频繁，调用开销大，算下来性价比不高，这时候我们就可以将这个函数声明为内联函数。编译器在编译过程中遇到内联函数，像宏一样，将内联函数直接在调用处展开，这样做就减少了函数调用的开销：直接执行内联函数展开的代码，不用再保存现场和恢复现场。

## 2. 内联函数和宏
内联函数和宏的功能差不多，那么为什么不直接定义一个宏，而去定义一个内联函数呢？

与宏相比，内联函数有以下优势。
- 参数类型检查：内联函数虽然具有宏的展开特性，但其本质仍是函数，在编译过程中，编译器仍可以对其进行参数检查，而宏不具备这个功能。
- 便于调试：函数支持的调试功能有断点、单步等，内联函数同样支持。
- 返回值：内联函数有返回值，返回一个结果给调用者。这个优势是相对于ANSI C说的，因为现在宏也可以有返回值和类型了，如前面使用语句表达式定义的宏。
- 接口封装：有些内联函数可以用来封装一个接口，而宏不具备这个特性。

## 3. 编译器对内联函数的处理
前面讲过，我们虽然可以通过inline关键字将一个函数声明为内联函数，但编译器不一定会对这个函数做内联展开。编译器也要根据实际情况进行评估，权衡展开和不展开的利弊，并最终决定要不要展开。

内联函数并不是完美无瑕的，也有一些缺点。内联函数会增大程序的体积，如果在一个文件中多次调用内联函数，多次展开，那么整个程序的体积就会变大，在一定程度上会降低程序的执行效率。函数的作用之一就是提高代码的复用性。我们将常用的一些代码或代码块封装成函数，进行模块化编程，可以减轻软件开发工作量。而内联函数往往又降低了函数的复用性。编译器在对内联函数做展开时，除了检测用户定义的内联函数内部是否有指针、循环、递归，还会在函数执行效率和函数调用开销之间进行权衡。一般来讲，判断对一个内联函数是否做展开，从程序员的角度出发，主要考虑如下因素。
- 函数体积小。
- 函数体内无指针赋值、递归、循环等语句。
- 调用频繁。

当我们认为一个函数体积小，而且被大量频繁调用，应该做内联展开时，就可以使用static inline关键字修饰它。但编译器不一定会做内联展开，如果你想明确告诉编译器一定要展开，或者不展开，就可以使用noinline或always_inline对函数做一个属性声明。

```c
static inline 
__attribute__((always_inline)) int func(int a)
{
    return a+1;
}

static inline void print_num(int a)
{
    printf("%d\n", a);
}

int main(int argc, char *argv[])
{
    int i;
    i=func(3);
    print_num(10);
    return 0;
}
```

在这个程序中，我们分别定义两个内联函数：func()和print_num()，然后使用always_inline对func()函数进行属性声明。编译这个源文件，并对生成的可执行文件a.out做反汇编处理，其汇编代码如下。

```bash
root@light-14-prd1:~/langurage_C# objdump -D a.out
...
...
000000000000064a <print_num>:
 64a:   55                      push   %rbp
 64b:   48 89 e5                mov    %rsp,%rbp
 64e:   48 83 ec 10             sub    $0x10,%rsp
 652:   89 7d fc                mov    %edi,-0x4(%rbp)
 655:   8b 45 fc                mov    -0x4(%rbp),%eax
 658:   89 c6                   mov    %eax,%esi
 65a:   48 8d 3d c3 00 00 00    lea    0xc3(%rip),%rdi        # 724 <_IO_stdin_used+0x4>
 661:   b8 00 00 00 00          mov    $0x0,%eax
 666:   e8 b5 fe ff ff          callq  520 <printf@plt>
 66b:   90                      nop
 66c:   c9                      leaveq 
 66d:   c3                      retq   

000000000000066e <main>:
 66e:   55                      push   %rbp
 66f:   48 89 e5                mov    %rsp,%rbp
 672:   48 83 ec 20             sub    $0x20,%rsp
 676:   89 7d ec                mov    %edi,-0x14(%rbp)
 679:   48 89 75 e0             mov    %rsi,-0x20(%rbp)
 67d:   c7 45 fc 03 00 00 00    movl   $0x3,-0x4(%rbp)
 684:   8b 45 fc                mov    -0x4(%rbp),%eax
 687:   83 c0 01                add    $0x1,%eax
 68a:   89 45 f8                mov    %eax,-0x8(%rbp)
 68d:   bf 0a 00 00 00          mov    $0xa,%edi
 692:   e8 b3 ff ff ff          callq  64a <print_num>
 697:   b8 00 00 00 00          mov    $0x0,%eax
 69c:   c9                      leaveq 
 69d:   c3                      retq   
 69e:   66 90                   xchg   %ax,%ax

```

通过反汇编代码可以看到，因为我们对func()函数作了always_inline属性声明，所以在编译过程中，在调用func()函数的地方，编译器会将 func() 函数在调用处直接展开，而不是像 print_num 函数一样跳转。

而对于print_num()函数，虽然我们对其做了内联声明，但编译器并没有对其做内联展开，而是把它当作一个普通函数对待。还有一个需要注意的细节是：当编译器对内联函数做展开处理时，会直接在调用处展开内联函数的代码，不再给func()函数本身生成单独的汇编代码。因为编译器在所有调用该函数的地方都做了内联展开，没必要再去生成单独的函数汇编指令。在这个例子中，我们发现编译器就没有给func()函数本身生成单独的汇编代码，编译器只给print_num()函数生成了独立的汇编代码。

## 4. 内联函数为什么定义在头文件中
在Linux内核中，你会看到大量的内联函数被定义在头文件中，而且常常使用static修饰。

为什么inline函数经常使用static修饰呢？这个问题在网上也讨论了很久，听起来各有道理，从C语言到C++，甚至有人还拿出了Linux内核作者Linus关于static inline的解释。

我们可以这样理解：内联函数为什么要定义在头文件中呢？因为它是一个内联函数，可以像宏一样使用，任何想使用这个内联函数的源文件，都不必亲自再去定义一遍，直接包含这个头文件，即可像宏一样使用。

那么为什么还要用static修饰呢？因为我们使用inline定义的内联函数，编译器不一定会内联展开，那么当一个工程中多个文件都包含这个内联函数的定义时，编译时就有可能报重定义错误。而使用static关键字修饰，则可以将这个函数的作用域限制在各自的文件内，避免重定义错误的发生。